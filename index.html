<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
<title>BRRRT! — Site</title>
<style>
/* ================= FONTS ================= */
@font-face {
  font-family: 'KomikaTitle';
  src: url('fonts/KOMIKAGL.ttf') format('truetype');
  font-weight: normal;
  font-style: normal;
}
@font-face {
  font-family: 'KomikaText';
  src: url('fonts/Komika.ttf') format('truetype');
  font-weight: normal;
  font-style: normal;
}

:root{
  /* --- COLOR INVERSION (Light Mode) --- */
  --bg:#f2f2f2;       /* Light Gray Background */
  --text-main:#1a1a1a;/* Dark Text */
  --muted:#666666;    /* Medium Gray Muted Text */
  --accent:#ff4444;   /* Accent stays the same (Red) */
  --btn:#e0e0e0;      /* Light Button Background */
  --btn-text:#000;    /* Dark Button Text */
  --sfx-bg:#d0d0d0;   /* Light SFX Pad */
  --sfx-border:#b0b0b0;
  /* --- New Waveform Colors --- */
  --waveform-fill: #b0b0b0; /* Unplayed Waveform Color */
  --waveform-progress: var(--accent); /* Played Waveform Color (Red Accent) */
}

/* base - Applying KomikaText to everything by default */
html,body{
  height:100%; margin:0;
  background:var(--bg); 
  color:var(--text-main); 
  font-family: 'KomikaText', Arial, Helvetica, sans-serif;
  -webkit-font-smoothing:antialiased;
  overflow-x:hidden;
  
  /* --- SECURITY: Disable Selection --- */
  user-select: none;
  -webkit-user-select: none;
}
*{box-sizing:border-box}

/* global section layout */
section{width:100%;min-height:100vh;display:flex;flex-direction:column;align-items:center;}

/* PAGE 1 compact */
#page1{padding-top:10px;padding-left:8px;padding-right:8px;}

/* Titles using KOMIKAGL */
.title-main {
  font-family: 'KomikaTitle', sans-serif;
  font-size:28px;
  line-height:1;
  margin:6px 0 0;
  font-weight:normal;
  letter-spacing:0.5px
}
.title-sub{font-size:14px;margin:2px 0 6px;color:var(--muted)}

/* Player area compact */
#player{display:flex;flex-direction:column;align-items:center;width:100%;max-width:420px;padding-bottom:6px}

/* Controls */
#controls{margin-top:6px;width:240px;display:flex;justify-content:space-between;align-items:center}
.control-btn{
  background:var(--btn);
  border:1px solid #ccc; 
  color:var(--btn-text);
  padding:8px 6px;
  border-radius:8px;
  font-size:14px;
  cursor:pointer;
  width:80px;
  min-width:72px;
  text-align:center;
  position:relative;
  overflow:visible; 
  font-family: 'KomikaText', sans-serif;
}
.hidden{ visibility:hidden; opacity:0; pointer-events:none; }
#likeButton { display:inline-flex; align-items:center; justify-content:center; }
#likeButton::after{ content: attr(data-icon); display:block; width:100%; text-align:center; font-size:16px; line-height:1; pointer-events:none; }
#likeButton.liked { background: var(--accent); color: #fff; border-color:var(--accent); }

/* Custom class for disabled button */
.disabled-btn { opacity: 0.5; pointer-events: none; } 

/* Wheel row grid */
#wheelRow{display:grid;grid-template-columns: 1fr auto 1fr;align-items:center;width:100%;max-width:420px;column-gap:22px;margin-top:8px}
#wheelCell{ display:flex; justify-content:center; align-items:center; }
#volumeCell{ display:flex; justify-content:flex-start; align-items:center; padding-left:6px; transform: translateX(-60px); }

/* jog wheel */
#jog-wheel{
  width:120px;height:120px;border-radius:50%;
  background: url('wheel.jpg') no-repeat center/cover;
  transform-origin:50% 50%;
  touch-action:none; 
  flex: 0 0 auto;
  cursor: grab;
  box-shadow: 0 4px 15px rgba(0,0,0,0.3); 
  position: relative;
  overflow: hidden; 
}
#jog-wheel:active { cursor: grabbing; }
#jog-wheel::after {
  content:''; position:absolute; top:5px; left:50%; transform:translateX(-50%);
  width:4px; height:15px; background:var(--accent); border-radius:2px;
  z-index: 10; 
}

/* Album Art Style */
#albumArt {
  width: 100%; 
  height: 100%;
  object-fit: cover;
  border-radius: 50%;
  position: absolute;
  top: 0; left: 0;
  pointer-events: none; 
  display: none; 
  z-index: 1;
}

/* volume knob */
.volume-wrap{
  display:flex;flex-direction:column;align-items:center;gap:8px;
  user-select:none;touch-action:none;
  margin-left:8px;transform: scale(0.7);transform-origin: center top;
}
.volume-label{font-size:12px;color:var(--muted);margin-bottom:2px}
.volume-slider{ -webkit-appearance:none; appearance:none; width:110px; height:26px; background:transparent; transform: rotate(-90deg); outline:none; cursor:pointer; }
/* Darker track for light background */
.volume-slider::-webkit-slider-runnable-track{ width:100%; height:6px; background:#ccc; border-radius:6px; }
.volume-slider::-webkit-slider-thumb{ -webkit-appearance:none; width:18px;height:18px;border-radius:50%;background:#fff;margin-top:-6px; box-shadow:0 0 0 3px rgba(255,68,68,0.2); border: 1px solid #ddd; }

/* Track name */
#trackName{
  margin-top:8px;
  color:var(--muted);
  font-size:12px;
  min-height: 18px; 
  display: flex;
  align-items: center;
  justify-content: center;
}

/* --- NEW WAVEFORM STYLES (Updated for display-only) --- */
#waveformContainer {
    width: 100%;
    max-width: 80px;
    height: 30px; /* Adjusted height for compactness */
    margin-top: 10px; /* Space below the track name */
    display: flex;
    justify-content: center; /* Center the canvas */
    align-items: center;
    cursor: default; /* Set to default to remove interactivity hint */
}

#waveformCanvas {
    width: 100%;
    height: 100%;
    /* Ensure the canvas is display:block to avoid issues */
    display: block; 
}
/* ----------------------------- */

/* SFX block */
.sfx-block{margin-top:12px;display:flex;flex-direction:column;align-items:center;width:100%}
#sfx-grid-inner{display:grid;grid-template-columns:repeat(3,80px);grid-gap:10px;justify-content:center;margin-top:12px}
.sfx-button{
  width:80px;height:80px;border-radius:8px;
  background:var(--sfx-bg);
  border:2px solid var(--sfx-border);
  display:flex;align-items:center;justify-content:center;
  font-size:16px;cursor:pointer;user-select:none;position:relative;
  color:var(--text-main);
  font-family: 'KomikaTitle', sans-serif;
}
.sfx-number{position:absolute;top:6px;left:50%;transform:translateX(-50%);pointer-events:none;font-weight:normal;font-size:14px; opacity:0.6;}
.sfx-button:active{transform:scale(0.97);background:var(--accent); color:#fff; border-color:var(--accent);}

/* Staggered Animation Class */
.flash-red { animation: flickerRed 0.2s ease-out forwards; }

#refreshButton{margin-top:12px;padding:8px 16px;font-size:14px;background:var(--btn);color:var(--btn-text);border:1px solid #ccc;border-radius:8px;cursor:pointer; font-family: 'KomikaText', sans-serif;}

/* PAGE 2 & 3 Styles */
#page2, #page3 { 
  padding:18px; 
  display:flex; 
  flex-direction:column; 
  align-items:center; 
  text-align:center; 
  background:#e8e8e8; /* Slightly darker than main bg to separate sections */
}
#page3 { background:#dedede; }

/* Section Titles using KOMIKAGL */
.page2-title, .page3-title { 
  font-family: 'KomikaTitle', sans-serif;
  padding-top:28px; 
  font-size:24px; 
  font-weight:normal; 
  margin-bottom:12px; 
  color: var(--text-main);
}
.page2-text, .page3-text { max-width:720px; color:var(--muted); text-align:left; margin:6px 8px; font-size:15px; line-height:1.45; }
.page2-photo, .page3-photo { margin-top:14px; border-radius:8px; object-fit:contain; width:50%; height:auto; }

/* Partners strip */
#partners-strip{
  position:relative;
  width:100%;
  overflow:hidden;
  height:80px;
  margin-top:12px;
  display:flex;
  align-items:center;
  touch-action: none; /* Crucial for preventing default scroll on drag */
}

#partners-strip-inner{
  display:flex; 
  position:absolute; 
  left:0; 
  top:50%; 
  white-space:nowrap; 
  /* The animation is now controlled entirely by JS physics loop */
  transform:translateY(-50%); 
  cursor: grab; 
  will-change: transform; 
}

#partners-strip-inner:active {
    cursor: grabbing;
}

#partners-strip-inner img{height:52px;margin:0 32px;display:inline-block}


@keyframes flickerRed{ 0%{background:var(--sfx-bg)} 50%{background:#ff4444} 100%{background:var(--sfx-bg)} }

/* responsive rules */
@media (max-width:980px){ .page2-photo, .page3-photo{ width:60%; } }
@media (max-width:720px){
  .page2-photo, .page3-photo{ width:90%; }
  .page2-text{ text-align:left; font-size:14px; }
  .title-main{font-size:24px}
  #jog-wheel{width:100px;height:100px}
  #sfx-grid-inner{grid-template-columns:repeat(3,72px);grid-gap:8px}
  .sfx-button{width:72px;height:72px;font-size:14px}
  .control-btn{width:72px;font-size:13px;padding:6px}
  #trackName{font-size:11px}
  #partners-strip-inner img{height:44px;margin:0 24px}
  
  /* Waveform on small screens */
  #waveformContainer {
    height: 30px; /* Adjusted smaller height on mobile */
  }
}
</style>
</head>
<body oncontextmenu="return false;" ondragstart="return false;" ondrop="return false;">

<section id="page1">
  <div style="text-align:center;">
    <div class="title-main">BRRRT¡</div>
    <div class="title-sub">audio studio</div>
  </div>

  <div id="player">
    <div id="controls">
      <button id="likeButton" class="control-btn hidden" data-icon="♡" aria-label="Like"></button>
      <button id="playButton" class="control-btn">Play</button>
      <button id="nextButton" class="control-btn hidden">Next</button>
    </div>

    <div id="wheelRow">
      <div></div>
      <div id="wheelCell">
        <div id="jog-wheel" role="slider" aria-label="Jog wheel">
            <img id="albumArt" src="" alt="Album Art">
        </div>
      </div>
      <div id="volumeCell">
        <div class="volume-wrap">
          <div class="volume-label">Vol</div>
          <input id="volumeSlider" class="volume-slider" type="range" min="0" max="1" step="0.01" aria-label="Music volume">
        </div>
      </div>
    </div>

    <div id="trackName"></div>
    
    <div id="waveformContainer">
        <canvas id="waveformCanvas"></canvas>
    </div>
    <div class="sfx-block" aria-label="SFX pads and refresh">
      <div id="sfx-grid-inner"></div>
      <button id="refreshButton" aria-label="Refresh SFX">Reload</button>
    </div>
  </div>
</section>

<section id="page2">
  <div style="text-align:center;margin-top:6px">
    <div class="page2-title">We put everything in context</div>
  </div>
  <div class="page2-text">
    we are gamers by heart so we get close with the game and team to capture the gamelay spirit,
    later we develop a concept and paint all sounds with it's colors..
    we also work in production timelines in & out of the engine to optimize our work performence
  </div>
  <img class="page2-photo" src="photo1.png" alt="photo1">
</section>

<section id="page3">
  <div style="text-align:center;margin-top:6px">
    <div class="page3-title">"Job your love"</div>
    <div class="page3-text">
      BRRRT¡ based in sunny Lisbon and our recording studio is furher down the valley where its magical
    </div> 
  </div>
  <img class="page3-photo" src="contact-photo.png" alt="Contact photo">
  <a href="https://www.instagram.com/brrrt.audio/" target="_blank" rel="noopener" style="margin-top:12px">
    <img src="instagram.png" alt="Instagram" style="width:48px;height:48px;margin-top:12px">
  </a>
  <div id="partners-strip">
    <div id="partners-strip-inner"></div>
  </div>
</section>

<script>
/* ================= SECURITY SHIELD ================= */
// Prevent Key Combinations for Save/Inspect
document.onkeydown = function(e) {
    if (e.keyCode == 123) { return false; } // Block F12
    if (e.ctrlKey && e.shiftKey && e.keyCode == 'I'.charCodeAt(0)) { return false; } // Block Ctrl+Shift+I
    if (e.ctrlKey && e.shiftKey && e.keyCode == 'C'.charCodeAt(0)) { return false; } // Block Ctrl+Shift+C
    if (e.ctrlKey && e.shiftKey && e.keyCode == 'J'.charCodeAt(0)) { return false; } // Block Ctrl+Shift+J
    if (e.ctrlKey && e.keyCode == 'U'.charCodeAt(0)) { return false; } // Block Ctrl+U
    if (e.ctrlKey && e.keyCode == 'S'.charCodeAt(0)) { return false; } // Block Ctrl+S
};

/* ================= SYSTEM INIT ================= */
const AudioCtx = window.AudioContext || window.webkitAudioContext;
const audioContext = new AudioCtx();
const musicGain = audioContext.createGain();
musicGain.connect(audioContext.destination);

/* Persistence */
const savedVolume = localStorage.getItem('brrrt_music_volume')!==null ? parseFloat(localStorage.getItem('brrrt_music_volume')) : 0.8;
musicGain.gain.value = savedVolume;
let likes=JSON.parse(localStorage.getItem('trackLikes')||'{}');

/* State Variables */
let audioBuffer=null, source=null;
let isPlaying = false;
let currentTrack = null; 
let lastPlayedTrackUrl = ''; 
let trackQueue = []; 

/* Vinyl Physics Variables */
let isScrubbing = false;
let isHolding = false;
let playHeadTime = 0;       
let currentVelocity = 0;    
let targetVelocity = 0;     
let wheelRotation = 0;
let lastPointerX = 0;
let lastTimestamp = performance.now(); // Initialized here for the main loop

/* --- WAVEFORM VARIABLES --- */
let waveformPeaks = []; // Stores the calculated peak data for drawing
const canvas = document.getElementById('waveformCanvas');
const ctx = canvas.getContext('2d');
const DENSITY_FACTOR = 6; // <--- NEW: Controls the visual density (4 means 4 pixels of data are aggregated into one peak)
/* -------------------------- */

/* DOM */
const playButton=document.getElementById('playButton');
const nextButton=document.getElementById('nextButton');
const likeButton=document.getElementById('likeButton');
const jogWheel=document.getElementById('jog-wheel');
const trackNameDiv=document.getElementById('trackName');
const volumeSlider=document.getElementById('volumeSlider');
volumeSlider.value=savedVolume; 
const albumArtImg = document.getElementById('albumArt'); 

/* Files */
const musicPath='audio/music/';
const trackList=[
    { url: 'Afternoon Adventure.ogg', display: 'Afternoon Adventure' },
    { url: 'a Swing Of Cards.ogg', display: 'a Swing Of Cards' },
    { url: 'Count The Yellow Cars.ogg', display: 'Count The Yellow Cars' },
    { url: 'Premium Dice.mp3', display: 'Premium Dice' },
    { url: 'Digital Dungeon.ogg', display: 'Digital Dungeon' },
    { url: 'Estoria Warned You.mp3', display: 'Estoria Warned You' },
    { url: 'Factory Settings.ogg', display: 'Factory Settings' },
    { url: 'Fits In My Garage.ogg', display: 'Fits In My Garage' }, 
    { url: 'Halloween Machine.ogg', display: 'Halloween Machine' },
    { url: 'Hawaiian Serenety.ogg', display: 'Hawaiian Serenety' },
    { url: 'Hunted Dungeon.mp3', display: 'Hunted Dungeon' },
    { url: 'Id Love To Be There.mp3', display: 'Id Love To Be There' },
    { url: 'Mansion Halls.ogg', display: 'Mansion Halls' },
    { url: 'Match Masters Live Band.ogg', display: 'Match Masters Live Band' },
    { url: 'Retroy.ogg', display: 'Retroy' },
    { url: 'Thats One Busy Lobby.ogg', display: 'Thats One Busy Lobby' },
    { url: 'The Good Ol Candyland.ogg', display: 'The Good Ol Candyland' },
    { url: 'The Voltgard Climb.ogg', display: 'The Voltgard Climb' },
    { url: 'Trick Or Deal.ogg', display: 'Trick Or Deal' },
    { url: 'Warm Winter Cabin.ogg', display: 'Warm Winter Cabin' },
    { url: 'Thanksgiving Memory Trail.ogg', display: 'Thanksgiving Memory Trail' },
];

let tracks = trackList.map(t => ({
    url: musicPath + encodeURI(t.url),
    display: t.display
}));


/* ================= SHUFFLE LOGIC ================= */

function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}

function getNextTrackFromQueue() {
    if (trackQueue.length === 0) {
        trackQueue = [...tracks]; 
        shuffleArray(trackQueue); 
        
        if (currentTrack && trackQueue.length > 1 && trackQueue[0].url === currentTrack.url) {
            const swapIndex = Math.floor(Math.random() * (trackQueue.length - 1)) + 1;
            [trackQueue[0], trackQueue[swapIndex]] = [trackQueue[swapIndex], trackQueue[0]];
        }
    }
    return trackQueue.pop(); 
}

/* ================= WAVEFORM CALCULATION AND DRAWING (UPDATED FOR DENSITY) ================= */

function getWaveformPeaks(audioBuffer, width) {
    if (!audioBuffer) return [];
    
    const data = audioBuffer.getChannelData(0); 
    const totalSamples = data.length;
    const peaks = [];
    
    // Calculate the number of visual peaks we actually want to draw, controlled by DENSITY_FACTOR.
    const numPeaksToDraw = Math.ceil(width / DENSITY_FACTOR); 
    
    // Number of samples to process per final *visual peak*.
    const samplesPerPeak = totalSamples / numPeaksToDraw; 
    
    for (let i = 0; i < numPeaksToDraw; i++) {
        const startSample = Math.floor(i * samplesPerPeak);
        const endSample = Math.floor((i + 1) * samplesPerPeak);
        
        let maxPeak = 0;
        
        // Find the maximum absolute peak within this window
        for (let j = startSample; j < endSample; j++) {
            const sample = Math.abs(data[j]);
            if (sample > maxPeak) {
                maxPeak = sample;
            }
        }
        peaks.push(maxPeak);
    }
    return peaks;
}

function drawWaveform() {
    if (!audioBuffer || waveformPeaks.length === 0) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        return;
    }
    
    // Match canvas dimensions to actual visible dimensions
    const width = canvas.offsetWidth;
    const height = canvas.offsetHeight;
    
    if (canvas.width !== width || canvas.height !== height) {
        canvas.width = width;
        canvas.height = height;
        // Recalculate peaks if the width changes (e.g., screen rotation)
        waveformPeaks = getWaveformPeaks(audioBuffer, width); 
    }
    
    ctx.clearRect(0, 0, width, height);
    
    const center = height / 2;
    const totalDuration = audioBuffer.duration;
    
    // Calculate the width of each bar on the canvas
    const peakBarWidth = width / waveformPeaks.length; 
    
    // Calculate the X-coordinate for the current playhead time
    const playedX = Math.min(width, Math.max(0, (playHeadTime / totalDuration) * width)); 

    ctx.beginPath();
    ctx.lineCap = 'butt';
    ctx.lineWidth = 1;

    // --- Draw the UNPLAYED (Fill) Waveform ---
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--waveform-fill');
    
    for (let i = 0; i < waveformPeaks.length; i++) {
        // Calculate X position based on the new peak width
        const x = i * peakBarWidth; 
        const peak = waveformPeaks[i];
        // Scale peak from 0-1 to 0-half height, with a min size
        const barHeight = Math.max(1, peak * height * 0.9); 
        
        ctx.moveTo(x, center - barHeight / 2);
        ctx.lineTo(x, center + barHeight / 2);
    }
    ctx.stroke();

    // --- Draw the PLAYED (Progress) Waveform ---
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--waveform-progress');
    
    ctx.beginPath();
    for (let i = 0; i < waveformPeaks.length; i++) {
        // Stop drawing the progress if we hit the play head
        const x = i * peakBarWidth; 
        if (x > playedX) break; 
        
        const peak = waveformPeaks[i];
        const barHeight = Math.max(1, peak * height * 0.9);
        
        ctx.moveTo(x, center - barHeight / 2);
        ctx.lineTo(x, center + barHeight / 2);
    }
    ctx.stroke();
}

/* ================= AUDIO ENGINE ================= */

async function loadTrack(trackObject){
  const url = trackObject.url;
  
  // ... (Album Art loading logic remains the same) ...
  const filenameNoExt = trackObject.display; 
  albumArtImg.style.display = 'none'; 
  
  const underscoreFilename = filenameNoExt.replace(/ /g, '_');
  const pathsToTry = [
      `visual/album_art/${underscoreFilename}.png`, 
      `visual/album_art/${filenameNoExt}.png`,      
      `visual/album_art/${underscoreFilename}.jpg`,
      `visual/album_art/${filenameNoExt}.jpg`       
  ];
  
  let pathIndex = 0;
  
  function attemptLoad() {
      if (pathIndex >= pathsToTry.length) {
          albumArtImg.style.display = 'none'; 
          return;
      }
      
      const currentPath = pathsToTry[pathIndex];
      
      albumArtImg.onload = () => {
          albumArtImg.style.display = 'block'; 
      };
      
      albumArtImg.onerror = () => {
          pathIndex++;
          attemptLoad();
      };

      albumArtImg.src = currentPath;
  }
  
  attemptLoad();
  // ... (End Album Art loading logic) ...

  try{
    trackNameDiv.textContent = ""; 

    const r=await fetch(url);
    const ab=await r.arrayBuffer();
    audioBuffer=await audioContext.decodeAudioData(ab);
    
    trackNameDiv.textContent = trackObject.display;
    currentTrack = trackObject;
    updateLikeButton();
    
    lastPlayedTrackUrl = trackObject.url; 
    
    // --- NEW: Generate waveform peaks after buffer loads ---
    // Use the *current* width of the canvas element
    waveformPeaks = getWaveformPeaks(audioBuffer, canvas.offsetWidth); 
    drawWaveform(); // Initial draw
    // ------------------------------------------------------
    
  }catch(e){
    console.error('loadTrack failed for URL:', url, 'Error:', e); 
    trackNameDiv.textContent="Error loading track"; 
    audioBuffer = null;
    waveformPeaks = [];
    drawWaveform(); // Clear canvas on error
  }
}

function startSource(startTimeOffset) {
  if(source) { 
    try{source.stop();}catch(e){} 
    source=null; 
  }
  
  const s = audioContext.createBufferSource();
  s.buffer = audioBuffer;
  s.connect(musicGain);
  s.loop = false;
  s.start(0, startTimeOffset);
  s.onended = () => {
    // Check if the source ended naturally (not from a manual stop or speed change)
    if(isPlaying && audioBuffer && (playHeadTime >= audioBuffer.duration - 0.1)) {
       playNext(); 
    }
  };
  return s;
}

function startRamp() {
  if (source && source.playbackRate) {
    source.playbackRate.value = 0.001; 
  }
  targetVelocity = 1.0; 
}

function playAudio() {
  if(!audioBuffer) return; 
  
  if (!source) {
      source = startSource(playHeadTime);
  } 
  
  isPlaying = true;
  playButton.textContent = 'Pause';
  nextButton.classList.remove('hidden');
  likeButton.classList.remove('hidden');
}

function pauseAudio() {
  isPlaying = false;
  targetVelocity = 0; 
  playButton.textContent = 'Play';
  setTimeout(() => {
    if(!isPlaying && Math.abs(currentVelocity) < 0.01) {
      if(source) { try{source.stop();}catch(e){} source=null; }
    }
  }, 500);
}

async function playNext(){
  const wasPlaying = isPlaying;
  
  if(source) {
    try { source.stop(); } catch(e) {}
    source = null; 
  }
  
  currentTrack = getNextTrackFromQueue(); 

  currentVelocity = 0;
  playHeadTime = 0;
  
  await loadTrack(currentTrack);
  
  if (wasPlaying) {
      playAudio(); 
      startRamp();
  } else {
      playButton.textContent = 'Play'; 
  }
}

async function loadRandomTrack() {
    currentTrack = getNextTrackFromQueue(); 
    await loadTrack(currentTrack);
}

/* ================= VINYL PHYSICS LOOP (UPDATED for waveform draw) ================= */

function updatePhysics() {
  const now = performance.now();
  const dt = (now - lastTimestamp) / 1000; 
  lastTimestamp = now;

  if(!audioBuffer) {
    requestAnimationFrame(updatePhysics);
    // Draw an empty or "loading" waveform
    drawWaveform(); 
    return;
  }

  // ... (Velocity and Play Head Time logic remains the same) ...

  if (isScrubbing) {
    const lerpFactor = 0.5; 
    currentVelocity = currentVelocity + (targetVelocity - currentVelocity) * lerpFactor;
  } else {
    const target = isPlaying ? 1.0 : 0.0;
    const inertia = isPlaying ? 10.0 : 8.0; 
    const diff = target - currentVelocity;
    if(Math.abs(diff) < 0.001) currentVelocity = target;
    else currentVelocity += diff * (dt * inertia);
  }

  if (source && source.playbackRate) {
    const newRate = Math.max(0, currentVelocity);
    source.playbackRate.setTargetAtTime(newRate, audioContext.currentTime, 0.01);
  } else if(currentVelocity !== 0 && !isPlaying) {
      currentVelocity *= 0.95; 
  }

  if (Math.abs(currentVelocity) > 0.005) { 
    playHeadTime += Math.max(0, currentVelocity) * dt;
    if(playHeadTime < 0) {
       playHeadTime = 0;
       currentVelocity = 0; 
    }
    if(audioBuffer && playHeadTime > audioBuffer.duration) { 
       playHeadTime = audioBuffer.duration;
       currentVelocity = 0; 
    }
  }

  // Visuals
  wheelRotation += (currentVelocity * 140) * dt;
  jogWheel.style.transform = `rotate(${wheelRotation}deg)`;
  
  // --- Draw the waveform ---
  drawWaveform(); 
  // -----------------------------

  requestAnimationFrame(updatePhysics);
}

requestAnimationFrame(updatePhysics);

/* ================= INPUT HANDLERS ================= */

jogWheel.addEventListener('pointerdown', async (e) => {
  e.preventDefault();
  jogWheel.setPointerCapture(e.pointerId);
  if(audioContext.state === 'suspended') await audioContext.resume();
  isScrubbing = true;
  isHolding = true;
  lastPointerX = e.clientX;
  targetVelocity = 0; 
  
  if (audioBuffer && !source) {
    source = startSource(playHeadTime); 
    if (source.playbackRate) {
        source.playbackRate.value = 0;
    }
  }
});

window.addEventListener('pointermove', (e) => {
  if (!isScrubbing) return;
  e.preventDefault();
  const dx = e.clientX - lastPointerX;
  lastPointerX = e.clientX;
  const sensitivity = 0.15; 
  targetVelocity = dx * sensitivity; 
});

window.addEventListener('pointerup', (e) => {
  if (!isScrubbing) return;
  isScrubbing = false;
  isHolding = false;
  if(playButton.textContent === 'Pause') { 
    targetVelocity = 1;
  }
});


/* ================= CONTROLS ================= */
playButton.addEventListener('click',async()=>{
  if(audioContext.state === 'suspended') await audioContext.resume();
  
  if(!isPlaying) {
      playAudio();
      startRamp();
  } else {
      pauseAudio();
  }
});

nextButton.addEventListener('click',async()=>{
  if(audioContext.state === 'suspended') await audioContext.resume();
  playNext(); 
});

volumeSlider.addEventListener('input',e=>{
  const v=parseFloat(e.target.value);
  musicGain.gain.setTargetAtTime(v,audioContext.currentTime, 0.1);
  localStorage.setItem('brrrt_music_volume',String(v));
});

likeButton.addEventListener('click',()=>{
  likes[currentTrack.url]=!likes[currentTrack.url];
  localStorage.setItem('trackLikes',JSON.stringify(likes));
  updateLikeButton();
});
function updateLikeButton(){
  const url = currentTrack ? currentTrack.url : '';
  likeButton.setAttribute('data-icon',likes[url]?'♥':'♡');
  likeButton.classList.toggle('liked',!!likes[url]);
}

/* ================= SFX ================= */
const sfxGridInner=document.getElementById('sfx-grid-inner');
const sfxButtons=[];
const sfxBuffers={};
const sfxPath='audio/sfx/';
const sfxFiles=['sfx1.ogg','sfx2.ogg','sfx3.ogg','sfx4.ogg','sfx5.ogg','sfx6.ogg','sfx7.ogg','sfx8.ogg','sfx9.ogg'];

for(let i=0;i<9;i++){
  const btn=document.createElement('div');
  btn.className='sfx-button';
  btn.innerHTML=`<div class="sfx-number">${i+1}</div>`;
  sfxGridInner.appendChild(btn);
  sfxButtons.push(btn);
}

async function loadSFX(url){
  if(sfxBuffers[url]) return sfxBuffers[url];
  try{
    const r=await fetch(url);
    const ab=await r.arrayBuffer();
    sfxBuffers[url]=await audioContext.decodeAudioData(ab);
    return sfxBuffers[url];
  }catch(e){ return null; }
}

function assignSFX(btn, url) {
  btn.onclick = async () => {
    if(audioContext.state === 'suspended') await audioContext.resume();
    const buf = await loadSFX(url);
    if(buf){
      const s = audioContext.createBufferSource();
      s.buffer = buf;
      s.connect(audioContext.destination);
      s.start(0);
      btn.classList.remove('flash-red');
      void btn.offsetWidth;
      btn.classList.add('flash-red');
    }
  }
}

function refreshSFX() {
  const available=[...sfxFiles];
  for(let i=available.length-1;i>0;i--){
    const j=Math.floor(Math.random()*(i+1));
    [available[i],available[j]]=[available[j],available[i]];
  }
  sfxButtons.forEach((btn, i) => {
    const file = available[i] || available[0];
    assignSFX(btn, sfxPath + file);
    setTimeout(() => {
      btn.classList.remove('flash-red');
      void btn.offsetWidth; 
      btn.classList.add('flash-red');
    }, i * 60);
  });
}

document.getElementById('refreshButton').addEventListener('click', async()=>{
  if(audioContext.state === 'suspended') await audioContext.resume();
  refreshSFX();
});

/* ================= PARTNERS STRIP LOGIC (Drag & Momentum) ================= */

const partnersInner=document.getElementById('partners-strip-inner');
const partnersStrip = document.getElementById('partners-strip');
const partnerFiles = [
    'icy_ghost.png', 'sneakyp.png', 'microsoft.png', 
    'scopely.png', 'lootheads.png', 'whalo.png', 'hearsay.png', 'glaive.png', 'okami.png', 'playspark.png', 'parana.png', 'uni.png', 'candivore.png', 'lineup.png', 'obscure.png', 'jelly.png', 'heimdall.png'
];

let isStripScrubbing = false;
let stripPosition = 0; // Current position in pixels
let stripVelocity = 0; // Current velocity (pixels/second)
let stripStartRate = -100; // The default scroll rate in pixels/second (TUNE THIS for speed: negative for left scroll)
let lastStripPointerX = 0;
let lastStripTimestamp = performance.now();
let setWidthPx = 0; // Measured width of one set of logos


function updateStripPhysics() {
  const now = performance.now();
  const dt = (now - lastStripTimestamp) / 1000; 
  lastStripTimestamp = now;

  if (isStripScrubbing) {
    // Velocity is handled directly in pointermove for immediate feedback
  } else {
    // Deceleration/Ramp-down when released
    const target = stripStartRate; 
    const inertia = 5.0; // Controls how quickly the strip returns to default speed
    const diff = target - stripVelocity;
    
    // Smoothly transition the velocity back to the default scroll rate
    if (Math.abs(diff) > 0.1) {
      stripVelocity += diff * (dt * inertia);
    } else {
      stripVelocity = target; 
    }
  }
  
  // Update position based on velocity
  stripPosition += stripVelocity * dt;

  // Seamless looping logic (Wraps the position back when it exceeds one set's width)
  if (setWidthPx > 0) {
      if (stripPosition < -setWidthPx) {
          // Scrolled past the end, reset to start
          stripPosition += setWidthPx;
      } else if (stripPosition > 0) {
          // Scrolled backward past the start, reset to the end
          stripPosition -= setWidthPx;
      }
  }

  // Apply the position visually: translate3d is used for hardware acceleration
  partnersInner.style.transform = `translate3d(${stripPosition}px, -50%, 0)`;

  requestAnimationFrame(updateStripPhysics);
}

// ... (Partners strip initialization and input handlers remain the same) ...

function setupPartnersStrip() {
    // Duplicate the logos to create the seamless loop effect
    const logoSet = partnersInner.innerHTML;
    partnersInner.innerHTML = logoSet + logoSet; 

    // Measure the width of a single set of logos
    // Must wait for images to load if possible, but we'll measure immediately for the loop
    const firstSet = partnersInner.children.length / 2;
    let totalWidth = 0;
    for(let i = 0; i < firstSet; i++) {
        const child = partnersInner.children[i];
        totalWidth += child.offsetWidth + (parseInt(getComputedStyle(child).marginLeft) * 2); 
    }
    setWidthPx = totalWidth;

    requestAnimationFrame(updateStripPhysics); 
}

// Partner Strip Drag Handlers
partnersStrip.addEventListener('pointerdown', (e) => {
    e.preventDefault(); 
    partnersStrip.setPointerCapture(e.pointerId);
    isStripScrubbing = true;
    lastStripPointerX = e.clientX;
    stripVelocity = 0; // Stop auto-scrolling instantly
    partnersInner.style.cursor = 'grabbing';
});

window.addEventListener('pointermove', (e) => {
    if (!isStripScrubbing) return;
    const dx = e.clientX - lastStripPointerX;
    lastStripPointerX = e.clientX;
    
    // Update position directly for immediate feedback
    stripPosition += dx;

    // Apply a large, immediate velocity proportional to the drag speed
    // This is useful if the physics loop isn't running very fast.
    stripVelocity = dx * (1000 / (performance.now() - lastStripTimestamp)); 
    
    lastStripTimestamp = performance.now();
});

window.addEventListener('pointerup', (e) => {
    if (!isStripScrubbing) return;
    isStripScrubbing = false;
    partnersInner.style.cursor = 'grab';
    
    // Resume physics loop, which will apply inertia to stripVelocity and eventually
    // transition back to stripStartRate.
});

// Load the partners strip images (for simple example)
partnerFiles.forEach(file => {
    const img = document.createElement('img');
    img.src = `visual/partners/${file}`;
    img.alt = '';
    partnersInner.appendChild(img);
});

/* ================= INIT ================= */
loadRandomTrack();
refreshSFX();
setupPartnersStrip();

</script>
</body>
</html>